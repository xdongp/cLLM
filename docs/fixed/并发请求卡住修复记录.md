# 并发请求卡住修复记录

## 问题概述
- 现象：并发压测时在第 12 个请求左右“卡住”，请求无法返回。
- 表现：HTTP 请求一直等待；日志显示批处理循环反复处理旧请求；队列长度持续增长。

## 根因定位
### 1) 请求队列未在进入 batch 后移除
- `Scheduler::processRequests()` 中从 `formBatch()` 取出请求后，没有将这些请求从队列移除。
- 结果：已完成请求仍停留在队列中，后续 `formBatch()` 反复拿到这些旧请求。
- `processBatch()` 里旧请求被过滤掉，真正的新请求无法进入执行，导致客户端等待超时。

### 2) KV 清理顺序错误导致 seq_id 失效
- 在 COMPLETED/FAILED/TIMEOUT 分支中，先 `releaseSequenceId()` 再 `cleanupKVCache()`。
- 释放 seq_id 后映射被删除，清理阶段找不到 seq_id，导致 KV cache 清理失败：
  - 日志：`Cannot clean KV cache: seqId not found`。

## 关键修复
### 1) 批处理后从队列移除已入批请求
- 在 `processRequests()` 中对 `batch` 中的每个请求调用 `requestQueue_.removeRequest(req.requestId)`。
- 避免旧请求反复占用队列，保证新请求能进入批处理。

### 2) 调整 KV 清理顺序
- 顺序改为：
  1. `updateKVCacheRequestStatus()`
  2. `cleanupKVCache()`（需要 seq_id）
  3. `releaseSequenceId()`
- 确保清理阶段可正确定位 seq_id。

## 影响文件
- `src/scheduler/scheduler.cpp`

## 验证结果
- 并发 20 次请求不再在第 12 次卡住。
- 队列长度稳定，不再持续增长。
- KV cache 清理日志正常，不再出现 `seqId not found`。

## 经验总结
- **队列消费必须具备“入批即移除”语义**，否则会产生饥饿与重复处理。
- **资源清理需依赖的标识必须先清理再释放**，避免清理失效。
- 压测时应重点观察：队列长度、批处理过滤比例与 KV 清理日志，以便快速定位阻塞原因。
