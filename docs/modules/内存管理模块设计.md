# Memory Manager 模块详细设计

## 编程规范

本模块的编码实现遵循以下规范和约定：
- [C++编程规范.md](../../C++编程规范.md)：定义编码风格、命名规范等
- [生成代码规范.md](../生成代码规范.md)：定义代码生成流程、设计文档一致性要求、优化同步机制等

## 0. 要生成的文件

### 0.1 头文件（include/cllm/memory/）

根据[C++编程规范.md](../../C++编程规范.md)的命名规范，本模块需要生成以下头文件：

| 文件名 | 对应类/结构体 | 说明 |
|--------|--------------|------|
| `monitor.h` | `MemoryMonitor` | 全局内存监控器（单例模式） |
| `float_array.h` | `FloatArray` | 浮点数组RAII包装器 |
| `cache_manager.h` | `KVCacheMemoryManager` | KV缓存内存管理器 |
| `executor_manager.h` | `ModelExecutorMemoryManager` | 模型执行器内存管理器 |

### 0.2 源文件（src/memory/）

| 文件名 | 对应头文件 | 说明 |
|--------|-----------|------|
| `monitor.cpp` | `monitor.h` | MemoryMonitor类的实现 |
| `float_array.cpp` | `float_array.h` | FloatArray类的实现 |
| `cache_manager.cpp` | `cache_manager.h` | KVCacheMemoryManager类的实现 |
| `executor_manager.cpp` | `executor_manager.h` | ModelExecutorMemoryManager类的实现 |

### 0.3 测试文件（tests/）

| 文件名 | 测试目标 | 说明 |
|--------|---------|------|
| `test_memory_monitor.cpp` | MemoryMonitor | 内存监控器的单元测试 |
| `test_memory_manager.cpp` | KVCacheMemoryManager, ModelExecutorMemoryManager | 内存管理器的单元测试 |

### 0.4 文件命名规范说明

- **头文件名**：使用小写字母+下划线，与类名对应（大驼峰转小写下划线）
- **源文件名**：与对应头文件名保持一致
- **目录结构**：头文件位于 `include/cllm/memory/`，源文件位于 `src/memory/`
- **一致性原则**：所有文件命名遵循[C++编程规范.md](../../C++编程规范.md)第1.1节

## 1. 模块概述


### 1.1 模块职责

Memory Manager模块负责cLLM系统中的内存管理，包括：
- 全局内存监控和限制
- KV Cache的内存管理
- Model Executor的内存管理
- RAII包装器提供自动内存管理
- mimalloc集成提供高性能内存分配


经过调研，我们推荐使用以下成熟的第三方内存管理库：

| 库名称 | 开发者 | 特点 | 适用场景 |
|--------|--------|------|----------|
| **mimalloc** | 微软 | 高性能、跨平台、线程安全 | **推荐使用**，性能最优 |
| **TCMalloc** | Google | 优化小块内存分配、低碎片 | 高并发场景 |
| **Jemalloc** | Facebook | 可扩展、低延迟 | 多核服务器环境 |

**推荐选择：mimalloc**

选择理由：
- 性能显著优于系统分配器和tcmalloc（20-30%吞吐量提升）
- 跨平台支持（Linux、macOS、Windows）
- 线程安全，适合高并发场景
- 微软开源，维护活跃
- 集成简单，只需链接库即可
- 自动内存对齐，支持SIMD优化


### 1.2 模块目标

- 提供统一的内存管理接口
- 实现内存使用监控和限制
- 避免内存泄漏和内存溢出
- 提高内存分配性能
- 支持SIMD优化的内存对齐

### 1.3 设计原则

- **RAII优先**: 优先使用RAII包装器管理资源
- **性能优先**: 使用mimalloc提高内存分配性能
- **安全优先**: 实现内存限制和监控，防止内存溢出
- **简洁优先**: 避免过度设计，保持接口简洁
- **可测试**: 所有组件都易于测试

## 2. 类设计

### 2.1 类图

```
┌─────────────────────────────────────────────────────────┐
│                    MemoryMonitor                          │
│  + instance(): MemoryMonitor&                            │
│  + setLimit(limit: size_t): void                          │
│  + getLimit(): size_t                                     │
│  + allocate(bytes: size_t): void                          │
│  + deallocate(bytes: size_t): void                        │
│  + getUsed(): size_t                                      │
│  + getPeak(): size_t                                      │
│  + setLimitCallback(callback: Callback): void             │
│  - usedMemory_: atomic<size_t>                            │
│  - peakMemory_: atomic<size_t>                            │
│  - memoryLimit_: atomic<size_t>                           │
│  - limitCallback_: Callback                               │
└─────────────────────────────────────────────────────────┘
                            ▲
                            │
┌───────────────────────────┼───────────────────────────────┐
│                           │                               │
┌───────────────────────────┴───────────────────────────────┐
│              KVCacheMemoryManager                         │
│  + KVCacheMemoryManager(maxMemoryMb: size_t)              │
│  + insert(requestId: string, keyCache: vector<float>,     │
│           valueCache: vector<float>): bool                 │
│  + get(requestId: string, keyCache: vector<float>&,       │
│        valueCache: vector<float>&): bool                  │
│  + evict(requestId: string): void                         │
│  + getUsedMemory(): size_t                                │
│  + getTotalMemory(): size_t                               │
│  + setEvictionCallback(callback: Callback): void           │
│  - cacheMap_: unordered_map<string, iterator>             │
│  - cacheList_: list<KVCacheEntry>                          │
│  - mutex_: mutex                                           │
│  - maxMemoryBytes_: size_t                                │
│  - evictionCallback_: Callback                            │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│           ModelExecutorMemoryManager                     │
│  + ModelExecutorMemoryManager(maxMemoryMb: size_t)        │
│  + allocateTempBuffer(size: size_t): void*               │
│  + deallocateTempBuffer(ptr: void*): void                 │
│  + allocateWeightsCache(size: size_t): void*              │
│  + deallocateWeightsCache(ptr: void*): void               │
│  + getTempMemoryUsed(): size_t                            │
│  + getWeightsMemoryUsed(): size_t                         │
│  + getTotalMemoryUsed(): size_t                           │
│  + clearAll(): void                                       │
│  - buffers_: vector<BufferInfo>                           │
│  - maxMemoryBytes_: size_t                                │
│  - tempMemoryUsed_: size_t                                │
│  - weightsMemoryUsed_: size_t                             │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│                    FloatArray                             │
│  + FloatArray(size: size_t)                              │
│  + ~FloatArray()                                          │
│  + data(): float*                                         │
│  + data() const: const float*                             │
│  + size(): size_t                                         │
│  - data_: float*                                          │
│  - size_: size_t                                           │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│                   RAIIWrapper<T>                          │
│  + RAIIWrapper(ptr: T* = nullptr)                        │
│  + ~RAIIWrapper()                                         │
│  + get(): T*                                              │
│  + get() const: const T*                                  │
│  + release(): T*                                         │
│  + reset(ptr: T* = nullptr): void                        │
│  - ptr_: T*                                                │
└─────────────────────────────────────────────────────────┘
```

### 2.2 类职责

#### 2.2.1 MemoryMonitor

**职责**: 全局内存监控器，监控和限制系统的内存使用

**职责说明**:
- 提供单例模式的全局内存监控
- 设置和获取内存限制
- 记录内存分配和释放
- 统计峰值内存使用
- 提供内存超限回调

#### 2.2.2 KVCacheMemoryManager

**职责**: KV Cache内存管理器，管理KV缓存的内存使用

**职责说明**:
- 管理KV Cache的内存分配和释放
- 实现LRU淘汰策略
- 监控KV Cache的内存使用
- 提供缓存淘汰回调
- 线程安全的缓存操作

#### 2.2.3 ModelExecutorMemoryManager

**职责**: Model Executor内存管理器，管理模型推理的临时内存

**职责说明**:
- 管理临时缓冲区的内存分配和释放
- 管理权重缓存的内存分配和释放
- 监控模型推理的内存使用
- 提供内存清理功能
- 区分临时内存和权重内存

#### 2.2.4 FloatArray

**职责**: 浮点数数组RAII包装器，自动管理数组内存

**职责说明**:
- 自动分配和释放数组内存
- 提供数组访问接口
- 禁止拷贝，防止意外释放
- 使用mimalloc分配内存

#### 2.2.5 RAIIWrapper

**职责**: 通用RAII包装器，自动管理对象生命周期

**职责说明**:
- 自动分配和释放对象内存
- 提供对象访问接口
- 支持所有权转移
- 禁止拷贝，防止意外释放

### 2.3 类接口

#### 2.3.1 MemoryMonitor接口

```cpp
class MemoryMonitor {
public:
    typedef std::function<void(size_t used, size_t limit)> MemoryLimitCallback;
    
    static MemoryMonitor& instance();
    
    void setLimit(size_t limitBytes);
    size_t getLimit() const;
    
    void allocate(size_t bytes);
    void deallocate(size_t bytes);
    
    size_t getUsed() const;
    size_t getPeak() const;
    
    void setLimitCallback(MemoryLimitCallback callback);
    void resetPeak();
    
private:
    MemoryMonitor();
    
    MemoryMonitor(const MemoryMonitor&) = delete;
    MemoryMonitor& operator=(const MemoryMonitor&) = delete;
    
    std::atomic<size_t> usedMemory_;
    std::atomic<size_t> peakMemory_;
    std::atomic<size_t> memoryLimit_;
    MemoryLimitCallback limitCallback_;
};
```

#### 2.3.2 KVCacheMemoryManager接口

```cpp
struct KVCacheEntry {
    std::string requestId;
    std::vector<float> keyCache;
    std::vector<float> valueCache;
    size_t sequenceLength;
    std::chrono::steady_clock::time_point lastAccess;
    size_t memoryUsage;
    size_t accessCount;
};

class KVCacheMemoryManager {
public:
    typedef std::function<void(const std::string&)> EvictionCallback;
    
    explicit KVCacheMemoryManager(size_t maxMemoryMb);
    
    bool insert(const std::string& requestId,
                const std::vector<float>& keyCache,
                const std::vector<float>& valueCache);
    
    bool get(const std::string& requestId,
             std::vector<float>& keyCache,
             std::vector<float>& valueCache);
    
    void evict(const std::string& requestId);
    
    size_t getUsedMemory() const;
    size_t getTotalMemory() const;
    
    void setEvictionCallback(EvictionCallback callback);
    
private:
    void evictOldest();
    size_t calculateMemoryUsage(const std::vector<float>& keyCache,
                                const std::vector<float>& valueCache);
    
    std::unordered_map<std::string, std::list<KVCacheEntry>::iterator> cacheMap_;
    std::list<KVCacheEntry> cacheList_;
    mutable std::mutex mutex_;
    size_t maxMemoryBytes_;
    EvictionCallback evictionCallback_;
};
```

#### 2.3.3 ModelExecutorMemoryManager接口

```cpp
struct BufferInfo {
    void* ptr;
    size_t size;
    bool isTemp;
};

class ModelExecutorMemoryManager {
public:
    explicit ModelExecutorMemoryManager(size_t maxMemoryMb);
    
    void* allocateTempBuffer(size_t size);
    void deallocateTempBuffer(void* ptr);
    
    void* allocateWeightsCache(size_t size);
    void deallocateWeightsCache(void* ptr);
    
    size_t getTempMemoryUsed() const;
    size_t getWeightsMemoryUsed() const;
    size_t getTotalMemoryUsed() const;
    
    void clearAll();
    
private:
    std::vector<BufferInfo> buffers_;
    size_t maxMemoryBytes_;
    size_t tempMemoryUsed_;
    size_t weightsMemoryUsed_;
};
```

#### 2.3.4 FloatArray接口

```cpp
class FloatArray {
public:
    explicit FloatArray(size_t size);
    ~FloatArray();
    
    float* data();
    const float* data() const;
    size_t size() const;
    
private:
    FloatArray(const FloatArray&) = delete;
    FloatArray& operator=(const FloatArray&) = delete;
    
    float* data_;
    size_t size_;
};
```

#### 2.3.5 RAIIWrapper接口

```cpp
template<typename T>
class RAIIWrapper {
public:
    explicit RAIIWrapper(T* ptr = nullptr);
    ~RAIIWrapper();
    
    T* get();
    const T* get() const;
    
    T* release();
    void reset(T* ptr = nullptr);
    
private:
    RAIIWrapper(const RAIIWrapper&) = delete;
    RAIIWrapper& operator=(const RAIIWrapper&) = delete;
    
    T* ptr_;
};
```

### 2.4 类关系

- **MemoryMonitor**: 单例模式，全局唯一实例
- **KVCacheMemoryManager**: 独立实例，管理KV Cache内存
- **ModelExecutorMemoryManager**: 独立实例，管理模型推理内存
- **FloatArray**: 独立实例，RAII包装器
- **RAIIWrapper**: 模板类，通用RAII包装器

## 3. 数据结构

### 3.1 KVCacheEntry

```cpp
struct KVCacheEntry {
    std::string requestId;                                      // 请求ID
    std::vector<float> keyCache;                               // Key缓存
    std::vector<float> valueCache;                             // Value缓存
    size_t sequenceLength;                                     // 序列长度
    std::chrono::steady_clock::time_point lastAccess;          // 最后访问时间
    size_t memoryUsage;                                         // 内存使用量（字节）
    size_t accessCount;                                         // 访问次数
};
```

**说明**: KV缓存条目，存储请求的Key和Value缓存信息

### 3.2 BufferInfo

```cpp
struct BufferInfo {
    void* ptr;                                                  // 缓冲区指针
    size_t size;                                                // 缓冲区大小
    bool isTemp;                                                // 是否为临时缓冲区
};
```

**说明**: 缓冲区信息，记录缓冲区的指针、大小和类型

### 3.3 MemoryLimitCallback

```cpp
typedef std::function<void(size_t used, size_t limit)> MemoryLimitCallback;
```

**说明**: 内存超限回调函数类型

### 3.4 EvictionCallback

```cpp
typedef std::function<void(const std::string&)> EvictionCallback;
```

**说明**: 缓存淘汰回调函数类型

## 4. 接口设计

### 4.1 公共接口

#### 4.1.1 MemoryMonitor公共接口

```cpp
// 获取单例实例
static MemoryMonitor& instance();

// 设置内存限制
void setLimit(size_t limitBytes);

// 获取内存限制
size_t getLimit() const;

// 分配内存
void allocate(size_t bytes);

// 释放内存
void deallocate(size_t bytes);

// 获取已使用内存
size_t getUsed() const;

// 获取峰值内存
size_t getPeak() const;

// 设置内存超限回调
void setLimitCallback(MemoryLimitCallback callback);

// 重置峰值内存
void resetPeak();
```

#### 4.1.2 KVCacheMemoryManager公共接口

```cpp
// 插入缓存
bool insert(const std::string& requestId,
            const std::vector<float>& keyCache,
            const std::vector<float>& valueCache);

// 获取缓存
bool get(const std::string& requestId,
         std::vector<float>& keyCache,
         std::vector<float>& valueCache);

// 淘汰缓存
void evict(const std::string& requestId);

// 获取已使用内存
size_t getUsedMemory() const;

// 获取总内存
size_t getTotalMemory() const;

// 设置淘汰回调
void setEvictionCallback(EvictionCallback callback);
```

#### 4.1.3 ModelExecutorMemoryManager公共接口

```cpp
// 分配临时缓冲区
void* allocateTempBuffer(size_t size);

// 释放临时缓冲区
void deallocateTempBuffer(void* ptr);

// 分配权重缓存
void* allocateWeightsCache(size_t size);

// 释放权重缓存
void deallocateWeightsCache(void* ptr);

// 获取临时内存使用量
size_t getTempMemoryUsed() const;

// 获取权重内存使用量
size_t getWeightsMemoryUsed() const;

// 获取总内存使用量
size_t getTotalMemoryUsed() const;

// 清空所有缓冲区
void clearAll();
```

#### 4.1.4 FloatArray公共接口

```cpp
// 构造函数
explicit FloatArray(size_t size);

// 析构函数
~FloatArray();

// 获取数据指针
float* data();

// 获取数据指针（const）
const float* data() const;

// 获取数组大小
size_t size() const;
```

#### 4.1.5 RAIIWrapper公共接口

```cpp
// 构造函数
explicit RAIIWrapper(T* ptr = nullptr);

// 析构函数
~RAIIWrapper();

// 获取指针
T* get();

// 获取指针（const）
const T* get() const;

// 释放所有权
T* release();

// 重置指针
void reset(T* ptr = nullptr);
```

### 4.2 私有接口

#### 4.2.1 KVCacheMemoryManager私有接口

```cpp
// 淘汰最旧的缓存
void evictOldest();

// 计算内存使用量
size_t calculateMemoryUsage(const std::vector<float>& keyCache,
                            const std::vector<float>& valueCache);
```

### 4.3 接口说明

#### 4.3.1 MemoryMonitor接口说明

- **instance()**: 获取全局单例实例
- **setLimit()**: 设置内存限制，单位为字节
- **getLimit()**: 获取当前内存限制
- **allocate()**: 记录内存分配，如果超过限制则抛出异常
- **deallocate()**: 记录内存释放
- **getUsed()**: 获取当前已使用内存
- **getPeak()**: 获取峰值内存使用
- **setLimitCallback()**: 设置内存超限回调函数
- **resetPeak()**: 重置峰值内存统计

#### 4.3.2 KVCacheMemoryManager接口说明

- **insert()**: 插入或更新KV缓存，如果内存不足则自动淘汰旧缓存
- **get()**: 获取KV缓存，如果不存在则返回false
- **evict()**: 手动淘汰指定请求的缓存
- **getUsedMemory()**: 获取当前KV Cache已使用内存
- **getTotalMemory()**: 获取KV Cache总内存限制
- **setEvictionCallback()**: 设置缓存淘汰回调函数

#### 4.3.3 ModelExecutorMemoryManager接口说明

- **allocateTempBuffer()**: 分配临时缓冲区，用于模型推理
- **deallocateTempBuffer()**: 释放临时缓冲区
- **allocateWeightsCache()**: 分配权重缓存，用于存储模型权重
- **deallocateWeightsCache()**: 释放权重缓存
- **getTempMemoryUsed()**: 获取临时内存使用量
- **getWeightsMemoryUsed()**: 获取权重内存使用量
- **getTotalMemoryUsed()**: 获取总内存使用量
- **clearAll()**: 清空所有缓冲区

#### 4.3.4 FloatArray接口说明

- **FloatArray()**: 构造函数，分配指定大小的浮点数数组
- **~FloatArray()**: 析构函数，自动释放数组内存
- **data()**: 获取数组数据指针
- **size()**: 获取数组大小

#### 4.3.5 RAIIWrapper接口说明

- **RAIIWrapper()**: 构造函数，接受对象指针
- **~RAIIWrapper()**: 析构函数，自动释放对象
- **get()**: 获取对象指针
- **release()**: 释放所有权，返回对象指针
- **reset()**: 重置指针，释放旧对象

## 5. 算法设计

### 5.1 LRU淘汰算法

#### 5.1.1 算法描述

KVCacheMemoryManager使用LRU（Least Recently Used）算法淘汰缓存，当内存不足时，优先淘汰最久未使用的缓存条目。

#### 5.1.2 算法流程

```
1. 当需要插入新缓存时，检查内存是否足够
2. 如果内存不足，执行以下步骤：
   a. 从缓存列表末尾获取最旧的缓存条目
   b. 从缓存映射中删除该条目
   c. 从缓存列表中删除该条目
   d. 更新内存使用统计
   e. 调用淘汰回调函数
3. 重复步骤2，直到内存足够或缓存为空
4. 如果内存仍然不足，返回false
5. 否则，插入新缓存并返回true
```

#### 5.1.3 性能分析

- **时间复杂度**: O(n)，n为需要淘汰的缓存条目数
- **空间复杂度**: O(1)，不需要额外空间
- **优化**: 使用双向链表+哈希表实现O(1)的插入和删除

### 5.2 内存监控算法

#### 5.2.1 算法描述

MemoryMonitor使用原子操作记录内存分配和释放，实时监控内存使用情况。

#### 5.2.2 算法流程

```
1. 分配内存时：
   a. 检查是否设置了内存限制
   b. 如果设置了限制，检查当前内存+分配量是否超过限制
   c. 如果超过限制，调用回调函数并抛出异常
   d. 否则，更新已使用内存
   e. 更新峰值内存（如果需要）

2. 释放内存时：
   a. 从已使用内存中减去释放量
```

#### 5.2.3 性能分析

- **时间复杂度**: O(1)，原子操作
- **空间复杂度**: O(1)，只存储几个原子变量
- **优化**: 使用原子操作避免锁竞争

### 5.3 内存计算算法

#### 5.3.1 算法描述

计算KV缓存条目的内存使用量，包括Key缓存和Value缓存。

#### 5.3.2 算法流程

```
1. 计算Key缓存的字节数：keyCache.size() * sizeof(float)
2. 计算Value缓存的字节数：valueCache.size() * sizeof(float)
3. 返回总字节数：keyBytes + valueBytes
```

#### 5.3.3 性能分析

- **时间复杂度**: O(1)，直接计算
- **空间复杂度**: O(1)，不需要额外空间

## 6. 并发设计

### 6.1 线程安全

#### 6.1.1 MemoryMonitor线程安全

- **使用原子变量**: usedMemory_、peakMemory_、memoryLimit_使用std::atomic
- **无锁设计**: 使用原子操作避免锁竞争
- **线程安全**: 所有操作都是线程安全的

#### 6.1.2 KVCacheMemoryManager线程安全

- **使用互斥锁**: cacheMap_、cacheList_使用std::mutex保护
- **细粒度锁**: 只在访问共享数据时加锁
- **线程安全**: 所有公共接口都是线程安全的

#### 6.1.3 ModelExecutorMemoryManager线程安全

- **不保证线程安全**: 假设单线程使用
- **如需线程安全**: 需要添加互斥锁保护buffers_

#### 6.1.4 FloatArray线程安全

- **不保证线程安全**: 假设单线程使用
- **如需线程安全**: 需要添加互斥锁保护data_

#### 6.1.5 RAIIWrapper线程安全

- **不保证线程安全**: 假设单线程使用
- **如需线程安全**: 需要添加互斥锁保护ptr_

### 6.2 同步机制

#### 6.2.1 原子操作

MemoryMonitor使用原子操作实现无锁并发：

```cpp
std::atomic<size_t> usedMemory_;
std::atomic<size_t> peakMemory_;
std::atomic<size_t> memoryLimit_;

// 分配内存
void allocate(size_t bytes) {
    size_t limit = memoryLimit_.load();
    if (limit > 0) {
        size_t used = usedMemory_.load();
        if (used + bytes > limit) {
            throw std::runtime_error("Memory limit exceeded");
        }
    }
    
    usedMemory_.fetch_add(bytes);
    
    // 更新峰值内存
    size_t current = usedMemory_.load();
    size_t peak = peakMemory_.load();
    while (current > peak) {
        if (peakMemory_.compare_exchange_weak(peak, current)) {
            break;
        }
    }
}
```

#### 6.2.2 互斥锁

KVCacheMemoryManager使用互斥锁保护共享数据：

```cpp
mutable std::mutex mutex_;

bool insert(const std::string& requestId,
            const std::vector<float>& keyCache,
            const std::vector<float>& valueCache) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    // 插入缓存
    // ...
}

bool get(const std::string& requestId,
         std::vector<float>& keyCache,
         std::vector<float>& valueCache) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    // 获取缓存
    // ...
}
```

### 6.3 并发策略

#### 6.3.1 MemoryMonitor并发策略

- **无锁设计**: 使用原子操作避免锁竞争
- **乐观并发**: 假设冲突较少，使用CAS操作
- **性能优化**: 减少锁等待时间

#### 6.3.2 KVCacheMemoryManager并发策略

- **悲观并发**: 使用互斥锁保护共享数据
- **细粒度锁**: 只在必要时加锁
- **性能优化**: 减少锁的持有时间

## 7. 内存管理

### 7.1 内存分配

#### 7.1.1 mimalloc集成

使用mimalloc替代系统malloc/free：

```cpp
#include <mimalloc.h>

// 分配内存
void* ptr = mi_malloc(size);

// 释放内存
mi_free(ptr);
```

#### 7.1.2 FloatArray内存分配

```cpp
FloatArray::FloatArray(size_t size)
    : data_(nullptr), size_(size) {
    data_ = (float*)mi_malloc(size * sizeof(float));
    if (!data_) {
        throw std::runtime_error("Failed to allocate FloatArray");
    }
}
```

#### 7.1.3 RAIIWrapper内存分配

```cpp
template<typename T>
RAIIWrapper<T>::RAIIWrapper(T* ptr) : ptr_(ptr) {
    if (!ptr_) {
        ptr_ = new T();
    }
}
```

### 7.2 内存释放

#### 7.2.1 FloatArray内存释放

```cpp
FloatArray::~FloatArray() {
    if (data_) {
        mi_free(data_);
        data_ = nullptr;
    }
}
```

#### 7.2.2 RAIIWrapper内存释放

```cpp
template<typename T>
RAIIWrapper<T>::~RAIIWrapper() {
    if (ptr_) {
        delete ptr_;
        ptr_ = nullptr;
    }
}
```

### 7.3 内存优化

#### 7.3.1 内存对齐

mimalloc自动处理内存对齐，支持SIMD优化：

```cpp
// mimalloc自动对齐到16/32/64字节
void* ptr = mi_malloc(size);  // 自动对齐
```

#### 7.3.2 内存复用

ModelExecutorMemoryManager支持内存复用：

```cpp
// 分配临时缓冲区
void* buffer = allocateTempBuffer(size);

// 使用缓冲区
processData(buffer);

// 释放缓冲区
deallocateTempBuffer(buffer);
```

## 8. 错误处理

### 8.1 错误类型

#### 8.1.1 内存分配失败

```cpp
// 抛出std::runtime_error
throw std::runtime_error("Failed to allocate memory");
```

#### 8.1.2 内存超限

```cpp
// 抛出std::runtime_error
throw std::runtime_error("Memory limit exceeded");
```

#### 8.1.3 缓存未找到

```cpp
// 返回false
bool get(const std::string& requestId, ...);
```

### 8.2 错误处理策略

#### 8.2.1 异常处理

使用异常处理内存分配失败：

```cpp
try {
    FloatArray array(1000000);
} catch (const std::runtime_error& e) {
    spdlog::error("Memory allocation failed: {}", e.what());
}
```

#### 8.2.2 回调处理

使用回调处理内存超限：

```cpp
MemoryMonitor::instance().setLimitCallback(
    [](size_t used, size_t limit) {
        spdlog::warn("Memory limit exceeded: {} / {}", used, limit);
    }
);
```

### 8.3 异常处理

#### 8.3.1 自定义异常

```cpp
class MemoryException : public std::exception {
public:
    explicit MemoryException(const std::string& message)
        : message_(message) {}
    
    const char* what() const noexcept override {
        return message_.c_str();
    }
    
private:
    std::string message_;
};
```

#### 8.3.2 异常安全

使用RAII确保异常安全：

```cpp
void process() {
    FloatArray array(100);  // 自动管理内存
    
    if (error) {
        throw std::runtime_error("Error");  // array自动释放
    }
}
```

## 9. 性能优化

### 9.1 优化策略

#### 9.1.1 使用mimalloc

- **性能提升**: 20-30%吞吐量提升
- **自动对齐**: 支持SIMD优化
- **线程安全**: 适合高并发场景

#### 9.1.2 使用原子操作

- **无锁设计**: 避免锁竞争
- **高性能**: 原子操作比互斥锁更快
- **可扩展**: 支持多核扩展

#### 9.1.3 细粒度锁

- **减少锁竞争**: 只在必要时加锁
- **提高并发**: 多线程可以并行执行
- **性能优化**: 减少锁等待时间

### 9.2 SIMD优化

#### 9.2.1 内存对齐

mimalloc自动处理内存对齐，支持SIMD优化：

```cpp
// 自动对齐到64字节，支持AVX-512
void* ptr = mi_malloc(size);
```

#### 9.2.2 SIMD友好的数据结构

使用连续内存存储数据，支持SIMD操作：

```cpp
std::vector<float> data;  // 连续内存，支持SIMD
```

### 9.3 缓存优化

#### 9.3.1 缓存友好

使用连续内存存储数据，提高缓存命中率：

```cpp
std::vector<float> data;  // 连续内存，缓存友好
```

#### 9.3.2 预分配内存

预分配内存，减少动态分配：

```cpp
std::vector<float> data;
data.reserve(1000);  // 预分配1000个元素
```

## 10. 测试设计

### 10.1 单元测试

#### 10.1.1 MemoryMonitor测试

```cpp
TEST(MemoryMonitorTest, SetLimit) {
    MemoryMonitor::instance().setLimit(1024);
    EXPECT_EQ(MemoryMonitor::instance().getLimit(), 1024);
}

TEST(MemoryMonitorTest, AllocateAndDeallocate) {
    MemoryMonitor::instance().setLimit(1024);
    MemoryMonitor::instance().allocate(512);
    EXPECT_EQ(MemoryMonitor::instance().getUsed(), 512);
    
    MemoryMonitor::instance().deallocate(256);
    EXPECT_EQ(MemoryMonitor::instance().getUsed(), 256);
}

TEST(MemoryMonitorTest, PeakMemory) {
    MemoryMonitor::instance().setLimit(1024);
    MemoryMonitor::instance().resetPeak();
    
    MemoryMonitor::instance().allocate(512);
    EXPECT_EQ(MemoryMonitor::instance().getPeak(), 512);
    
    MemoryMonitor::instance().allocate(256);
    EXPECT_EQ(MemoryMonitor::instance().getPeak(), 768);
    
    MemoryMonitor::instance().deallocate(256);
    EXPECT_EQ(MemoryMonitor::instance().getPeak(), 768);
}

TEST(MemoryMonitorTest, MemoryLimitExceeded) {
    MemoryMonitor::instance().setLimit(1024);
    MemoryMonitor::instance().resetPeak();
    
    EXPECT_THROW({
        MemoryMonitor::instance().allocate(2048);
    }, std::runtime_error);
}
```

#### 10.1.2 KVCacheMemoryManager测试

```cpp
TEST(KVCacheMemoryManagerTest, InsertAndGet) {
    KVCacheMemoryManager manager(100);
    
    std::vector<float> keyCache(100, 1.0f);
    std::vector<float> valueCache(100, 2.0f);
    
    EXPECT_TRUE(manager.insert("req1", keyCache, valueCache));
    
    std::vector<float> retrievedKey;
    std::vector<float> retrievedValue;
    EXPECT_TRUE(manager.get("req1", retrievedKey, retrievedValue));
    EXPECT_EQ(retrievedKey.size(), 100);
    EXPECT_EQ(retrievedValue.size(), 100);
}

TEST(KVCacheMemoryManagerTest, EvictOldest) {
    KVCacheMemoryManager manager(1);
    
    std::vector<float> keyCache(100, 1.0f);
    std::vector<float> valueCache(100, 2.0f);
    
    EXPECT_TRUE(manager.insert("req1", keyCache, valueCache));
    EXPECT_FALSE(manager.insert("req2", keyCache, valueCache));
}

TEST(KVCacheMemoryManagerTest, MemoryUsage) {
    KVCacheMemoryManager manager(100);
    
    std::vector<float> keyCache(100, 1.0f);
    std::vector<float> valueCache(100, 2.0f);
    
    manager.insert("req1", keyCache, valueCache);
    EXPECT_GT(manager.getUsedMemory(), 0);
    EXPECT_EQ(manager.getTotalMemory(), 100 * 1024 * 1024);
}
```

#### 10.1.3 FloatArray测试

```cpp
TEST(FloatArrayTest, AllocateAndAccess) {
    FloatArray array(100);
    
    EXPECT_EQ(array.size(), 100);
    EXPECT_NE(array.data(), nullptr);
    
    for (size_t i = 0; i < array.size(); ++i) {
        array.data()[i] = i * 1.0f;
    }
    
    for (size_t i = 0; i < array.size(); ++i) {
        EXPECT_FLOAT_EQ(array.data()[i], i * 1.0f);
    }
}

TEST(FloatArrayTest, AutoFree) {
    {
        FloatArray array(100);
        EXPECT_NE(array.data(), nullptr);
    }
    // array自动释放
}
```

#### 10.1.4 RAIIWrapper测试

```cpp
TEST(RAIIWrapperTest, AllocateAndAccess) {
    RAIIWrapper<float> wrapper(new float(42.0f));
    
    EXPECT_NE(wrapper.get(), nullptr);
    EXPECT_FLOAT_EQ(*wrapper.get(), 42.0f);
}

TEST(RAIIWrapperTest, Release) {
    RAIIWrapper<float> wrapper(new float(42.0f));
    
    float* ptr = wrapper.release();
    EXPECT_NE(ptr, nullptr);
    EXPECT_EQ(wrapper.get(), nullptr);
    
    delete ptr;
}

TEST(RAIIWrapperTest, Reset) {
    RAIIWrapper<float> wrapper(new float(42.0f));
    
    wrapper.reset(new float(24.0f));
    EXPECT_FLOAT_EQ(*wrapper.get(), 24.0f);
}
```

### 10.2 集成测试

#### 10.2.1 MemoryMonitor集成测试

```cpp
TEST(MemoryMonitorIntegration, MultipleThreads) {
    MemoryMonitor::instance().setLimit(1024 * 1024);
    MemoryMonitor::instance().resetPeak();
    
    std::vector<std::thread> threads;
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back([i]() {
            MemoryMonitor::instance().allocate(100 * 1024);
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
            MemoryMonitor::instance().deallocate(100 * 1024);
        });
    }
    
    for (auto& thread : threads) {
        thread.join();
    }
    
    EXPECT_EQ(MemoryMonitor::instance().getUsed(), 0);
}
```

#### 10.2.2 KVCacheMemoryManager集成测试

```cpp
TEST(KVCacheMemoryManagerIntegration, ConcurrentAccess) {
    KVCacheMemoryManager manager(100);
    
    std::vector<std::thread> threads;
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back([&manager, i]() {
            std::vector<float> keyCache(100, 1.0f);
            std::vector<float> valueCache(100, 2.0f);
            
            std::string requestId = "req" + std::to_string(i);
            manager.insert(requestId, keyCache, valueCache);
            
            std::vector<float> retrievedKey;
            std::vector<float> retrievedValue;
            manager.get(requestId, retrievedKey, retrievedValue);
        });
    }
    
    for (auto& thread : threads) {
        thread.join();
    }
}
```

### 10.3 性能测试

#### 10.3.1 MemoryMonitor性能测试

```cpp
TEST(MemoryMonitorPerformance, AllocateDeallocate) {
    MemoryMonitor::instance().setLimit(1024 * 1024 * 1024);
    MemoryMonitor::instance().resetPeak();
    
    auto start = std::chrono::high_resolution_clock::now();
    
    for (int i = 0; i < 1000000; ++i) {
        MemoryMonitor::instance().allocate(1024);
        MemoryMonitor::instance().deallocate(1024);
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    spdlog::info("MemoryMonitor performance: {} ms for 1000000 operations", duration.count());
}
```

#### 10.3.2 KVCacheMemoryManager性能测试

```cpp
TEST(KVCacheMemoryManagerPerformance, InsertAndGet) {
    KVCacheMemoryManager manager(1024);
    
    auto start = std::chrono::high_resolution_clock::now();
    
    for (int i = 0; i < 10000; ++i) {
        std::vector<float> keyCache(100, 1.0f);
        std::vector<float> valueCache(100, 2.0f);
        
        std::string requestId = "req" + std::to_string(i);
        manager.insert(requestId, keyCache, valueCache);
        
        std::vector<float> retrievedKey;
        std::vector<float> retrievedValue;
        manager.get(requestId, retrievedKey, retrievedValue);
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    spdlog::info("KVCacheMemoryManager performance: {} ms for 10000 operations", duration.count());
}
```

## 11. 代码示例

### 11.1 头文件示例

#### 11.1.1 memory_monitor.h

```cpp
/**
 * @file memory_monitor.h
 * @brief 内存监控器，监控和限制内存使用
 * @author cLLM Team
 * @date 2024-01-01
 */

#pragma once

#include <atomic>
#include <functional>
#include <string>

namespace cllm {

/**
 * @brief 内存监控器类
 */
class MemoryMonitor {
public:
    typedef std::function<void(size_t used, size_t limit)> MemoryLimitCallback;
    
    /**
     * @brief 获取单例实例
     * @return MemoryMonitor实例
     */
    static MemoryMonitor& instance();
    
    /**
     * @brief 设置内存限制
     * @param limitBytes 内存限制（字节）
     */
    void setLimit(size_t limitBytes);
    
    /**
     * @brief 获取内存限制
     * @return 内存限制（字节）
     */
    size_t getLimit() const;
    
    /**
     * @brief 分配内存
     * @param bytes 分配的字节数
     */
    void allocate(size_t bytes);
    
    /**
     * @brief 释放内存
     * @param bytes 释放的字节数
     */
    void deallocate(size_t bytes);
    
    /**
     * @brief 获取已使用内存
     * @return 已使用内存（字节）
     */
    size_t getUsed() const;
    
    /**
     * @brief 获取峰值内存
     * @return 峰值内存（字节）
     */
    size_t getPeak() const;
    
    /**
     * @brief 设置内存超限回调
     * @param callback 回调函数
     */
    void setLimitCallback(MemoryLimitCallback callback);
    
    /**
     * @brief 重置峰值内存
     */
    void resetPeak();
    
private:
    MemoryMonitor();
    
    MemoryMonitor(const MemoryMonitor&) = delete;
    MemoryMonitor& operator=(const MemoryMonitor&) = delete;
    
    std::atomic<size_t> usedMemory_;
    std::atomic<size_t> peakMemory_;
    std::atomic<size_t> memoryLimit_;
    MemoryLimitCallback limitCallback_;
};

}  // namespace cllm
```

#### 11.1.2 kv_cache_memory.h

```cpp
/**
 * @file kv_cache_memory.h
 * @brief KV缓存内存管理器
 * @author cLLM Team
 * @date 2024-01-01
 */

#pragma once

#include <list>
#include <mutex>
#include <string>
#include <unordered_map>
#include <vector>
#include <chrono>
#include <functional>

namespace cllm {

/**
 * @brief KV缓存条目
 */
struct KVCacheEntry {
    std::string requestId;
    std::vector<float> keyCache;
    std::vector<float> valueCache;
    size_t sequenceLength;
    std::chrono::steady_clock::time_point lastAccess;
    size_t memoryUsage;
    size_t accessCount;
};

/**
 * @brief KV缓存内存管理器类
 */
class KVCacheMemoryManager {
public:
    typedef std::function<void(const std::string&)> EvictionCallback;
    
    /**
     * @brief 构造函数
     * @param maxMemoryMb 最大内存（MB）
     */
    explicit KVCacheMemoryManager(size_t maxMemoryMb);
    
    /**
     * @brief 插入缓存
     * @param requestId 请求ID
     * @param keyCache Key缓存
     * @param valueCache Value缓存
     * @return 是否成功插入
     */
    bool insert(const std::string& requestId,
                const std::vector<float>& keyCache,
                const std::vector<float>& valueCache);
    
    /**
     * @brief 获取缓存
     * @param requestId 请求ID
     * @param keyCache 输出Key缓存
     * @param valueCache 输出Value缓存
     * @return 是否成功获取
     */
    bool get(const std::string& requestId,
             std::vector<float>& keyCache,
             std::vector<float>& valueCache);
    
    /**
     * @brief 淘汰缓存
     * @param requestId 请求ID
     */
    void evict(const std::string& requestId);
    
    /**
     * @brief 获取已使用内存
     * @return 已使用内存（字节）
     */
    size_t getUsedMemory() const;
    
    /**
     * @brief 获取总内存
     * @return 总内存（字节）
     */
    size_t getTotalMemory() const;
    
    /**
     * @brief 设置淘汰回调
     * @param callback 回调函数
     */
    void setEvictionCallback(EvictionCallback callback);
    
private:
    /**
     * @brief 淘汰最旧的缓存
     */
    void evictOldest();
    
    /**
     * @brief 计算内存使用量
     * @param keyCache Key缓存
     * @param valueCache Value缓存
     * @return 内存使用量（字节）
     */
    size_t calculateMemoryUsage(const std::vector<float>& keyCache,
                                const std::vector<float>& valueCache);
    
    std::unordered_map<std::string, std::list<KVCacheEntry>::iterator> cacheMap_;
    std::list<KVCacheEntry> cacheList_;
    mutable std::mutex mutex_;
    size_t maxMemoryBytes_;
    EvictionCallback evictionCallback_;
};

}  // namespace cllm
```

#### 11.1.3 raii_wrapper.h

```cpp
/**
 * @file raii_wrapper.h
 * @brief RAII包装器
 * @author cLLM Team
 * @date 2024-01-01
 */

#pragma once

#include <cstddef>

namespace cllm {

/**
 * @brief 浮点数数组RAII包装器
 */
class FloatArray {
public:
    /**
     * @brief 构造函数
     * @param size 数组大小
     */
    explicit FloatArray(size_t size);
    
    /**
     * @brief 析构函数
     */
    ~FloatArray();
    
    /**
     * @brief 获取数据指针
     * @return 数据指针
     */
    float* data();
    
    /**
     * @brief 获取数据指针（const）
     * @return 数据指针
     */
    const float* data() const;
    
    /**
     * @brief 获取数组大小
     * @return 数组大小
     */
    size_t size() const;
    
private:
    FloatArray(const FloatArray&) = delete;
    FloatArray& operator=(const FloatArray&) = delete;
    
    float* data_;
    size_t size_;
};

/**
 * @brief 通用RAII包装器
 */
template<typename T>
class RAIIWrapper {
public:
    /**
     * @brief 构造函数
     * @param ptr 对象指针
     */
    explicit RAIIWrapper(T* ptr = nullptr);
    
    /**
     * @brief 析构函数
     */
    ~RAIIWrapper();
    
    /**
     * @brief 获取指针
     * @return 对象指针
     */
    T* get();
    
    /**
     * @brief 获取指针（const）
     * @return 对象指针
     */
    const T* get() const;
    
    /**
     * @brief 释放所有权
     * @return 对象指针
     */
    T* release();
    
    /**
     * @brief 重置指针
     * @param ptr 对象指针
     */
    void reset(T* ptr = nullptr);
    
private:
    RAIIWrapper(const RAIIWrapper&) = delete;
    RAIIWrapper& operator=(const RAIIWrapper&) = delete;
    
    T* ptr_;
};

}  // namespace cllm
```

### 11.2 实现文件示例

#### 11.2.1 memory_monitor.cpp

```cpp
/**
 * @file memory_monitor.cpp
 * @brief 内存监控器实现
 */

#include "memory_monitor.h"
#include <stdexcept>
#include <spdlog/spdlog.h>

namespace cllm {

MemoryMonitor::MemoryMonitor() {
    usedMemory_ = 0;
    peakMemory_ = 0;
    memoryLimit_ = 0;
}

MemoryMonitor& MemoryMonitor::instance() {
    static MemoryMonitor instance;
    return instance;
}

void MemoryMonitor::setLimit(size_t limitBytes) {
    memoryLimit_.store(limitBytes);
    spdlog::info("Memory limit set to {} MB", limitBytes / (1024 * 1024));
}

size_t MemoryMonitor::getLimit() const {
    return memoryLimit_.load();
}

void MemoryMonitor::allocate(size_t bytes) {
    size_t limit = memoryLimit_.load();
    if (limit > 0) {
        size_t used = usedMemory_.load();
        if (used + bytes > limit) {
            if (limitCallback_) {
                limitCallback_(used, limit);
            }
            spdlog::error("Memory limit exceeded: {} + {} > {}", 
                         used, bytes, limit);
            throw std::runtime_error("Memory limit exceeded");
        }
    }
    
    usedMemory_.fetch_add(bytes);
    
    size_t current = usedMemory_.load();
    size_t peak = peakMemory_.load();
    while (current > peak) {
        if (peakMemory_.compare_exchange_weak(peak, current)) {
            break;
        }
    }
}

void MemoryMonitor::deallocate(size_t bytes) {
    usedMemory_.fetch_sub(bytes);
}

size_t MemoryMonitor::getUsed() const {
    return usedMemory_.load();
}

size_t MemoryMonitor::getPeak() const {
    return peakMemory_.load();
}

void MemoryMonitor::setLimitCallback(MemoryLimitCallback callback) {
    limitCallback_ = callback;
}

void MemoryMonitor::resetPeak() {
    peakMemory_.store(0);
}

}  // namespace cllm
```

#### 11.2.2 kv_cache_memory.cpp

```cpp
/**
 * @file kv_cache_memory.cpp
 * @brief KV缓存内存管理器实现
 */

#include "kv_cache_memory.h"
#include <spdlog/spdlog.h>

namespace cllm {

KVCacheMemoryManager::KVCacheMemoryManager(size_t maxMemoryMb)
    : maxMemoryBytes_(maxMemoryMb * 1024 * 1024) {
    spdlog::info("KVCacheMemoryManager initialized with {} MB", maxMemoryMb);
}

bool KVCacheMemoryManager::insert(const std::string& requestId,
                                  const std::vector<float>& keyCache,
                                  const std::vector<float>& valueCache) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    size_t memoryUsage = calculateMemoryUsage(keyCache, valueCache);
    
    size_t currentUsage = getUsedMemory();
    while (currentUsage + memoryUsage > maxMemoryBytes_ && !cacheList_.empty()) {
        evictOldest();
        currentUsage = getUsedMemory();
    }
    
    if (currentUsage + memoryUsage > maxMemoryBytes_) {
        return false;
    }
    
    KVCacheEntry entry;
    entry.requestId = requestId;
    entry.keyCache = keyCache;
    entry.valueCache = valueCache;
    entry.sequenceLength = keyCache.size();
    entry.lastAccess = std::chrono::steady_clock::now();
    entry.memoryUsage = memoryUsage;
    entry.accessCount = 0;
    
    cacheList_.push_front(entry);
    cacheMap_[requestId] = cacheList_.begin();
    
    return true;
}

bool KVCacheMemoryManager::get(const std::string& requestId,
                                std::vector<float>& keyCache,
                                std::vector<float>& valueCache) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    auto it = cacheMap_.find(requestId);
    if (it == cacheMap_.end()) {
        return false;
    }
    
    keyCache = it->second->keyCache;
    valueCache = it->second->valueCache;
    it->second->lastAccess = std::chrono::steady_clock::now();
    it->second->accessCount++;
    
    return true;
}

void KVCacheMemoryManager::evict(const std::string& requestId) {
    std::lock_guard<std::mutex> lock(mutex_);
    
    auto it = cacheMap_.find(requestId);
    if (it != cacheMap_.end()) {
        if (evictionCallback_) {
            evictionCallback_(requestId);
        }
        cacheList_.erase(it->second);
        cacheMap_.erase(it);
    }
}

size_t KVCacheMemoryManager::getUsedMemory() const {
    std::lock_guard<std::mutex> lock(mutex_);
    
    size_t total = 0;
    for (const auto& entry : cacheList_) {
        total += entry.memoryUsage;
    }
    return total;
}

size_t KVCacheMemoryManager::getTotalMemory() const {
    return maxMemoryBytes_;
}

void KVCacheMemoryManager::setEvictionCallback(
    std::function<void(const std::string&)> callback) {
    evictionCallback_ = callback;
}

void KVCacheMemoryManager::evictOldest() {
    if (cacheList_.empty()) {
        return;
    }
    
    auto& oldest = cacheList_.back();
    if (evictionCallback_) {
        evictionCallback_(oldest.requestId);
    }
    
    cacheMap_.erase(oldest.requestId);
    cacheList_.pop_back();
}

size_t KVCacheMemoryManager::calculateMemoryUsage(
    const std::vector<float>& keyCache,
    const std::vector<float>& valueCache) {
    return (keyCache.size() + valueCache.size()) * sizeof(float);
}

}  // namespace cllm
```

#### 11.2.3 raii_wrapper.cpp

```cpp
/**
 * @file raii_wrapper.cpp
 * @brief RAII包装器实现
 */

#include "raii_wrapper.h"
#include <stdexcept>
#include <mimalloc.h>

namespace cllm {

FloatArray::FloatArray(size_t size)
    : data_(nullptr), size_(size) {
    data_ = (float*)mi_malloc(size * sizeof(float));
    if (!data_) {
        throw std::runtime_error("Failed to allocate FloatArray");
    }
}

FloatArray::~FloatArray() {
    if (data_) {
        mi_free(data_);
        data_ = nullptr;
    }
}

float* FloatArray::data() {
    return data_;
}

const float* FloatArray::data() const {
    return data_;
}

size_t FloatArray::size() const {
    return size_;
}

template<typename T>
RAIIWrapper<T>::RAIIWrapper(T* ptr) : ptr_(ptr) {}

template<typename T>
RAIIWrapper<T>::~RAIIWrapper() {
    if (ptr_) {
        delete ptr_;
        ptr_ = nullptr;
    }
}

template<typename T>
T* RAIIWrapper<T>::get() {
    return ptr_;
}

template<typename T>
const T* RAIIWrapper<T>::get() const {
    return ptr_;
}

template<typename T>
T* RAIIWrapper<T>::release() {
    T* tmp = ptr_;
    ptr_ = nullptr;
    return tmp;
}

template<typename T>
void RAIIWrapper<T>::reset(T* ptr) {
    if (ptr_) {
        delete ptr_;
    }
    ptr_ = ptr;
}

}  // namespace cllm
```

### 11.3 使用示例

#### 11.3.1 MemoryMonitor使用示例

```cpp
#include "memory_monitor.h"

int main() {
    // 设置内存限制为1GB
    cllm::MemoryMonitor::instance().setLimit(1024 * 1024 * 1024);
    
    // 设置内存超限回调
    cllm::MemoryMonitor::instance().setLimitCallback(
        [](size_t used, size_t limit) {
            spdlog::warn("Memory limit exceeded: {} / {}", used, limit);
        }
    );
    
    // 分配内存
    cllm::MemoryMonitor::instance().allocate(512 * 1024 * 1024);
    
    // 获取内存使用情况
    size_t used = cllm::MemoryMonitor::instance().getUsed();
    size_t peak = cllm::MemoryMonitor::instance().getPeak();
    
    spdlog::info("Used memory: {} MB", used / (1024 * 1024));
    spdlog::info("Peak memory: {} MB", peak / (1024 * 1024));
    
    // 释放内存
    cllm::MemoryMonitor::instance().deallocate(512 * 1024 * 1024);
    
    return 0;
}
```

#### 11.3.2 KVCacheMemoryManager使用示例

```cpp
#include "kv_cache_memory.h"

int main() {
    // 创建KV缓存管理器，最大内存100MB
    cllm::KVCacheMemoryManager manager(100);
    
    // 设置淘汰回调
    manager.setEvictionCallback(
        [](const std::string& requestId) {
            spdlog::warn("Cache evicted: {}", requestId);
        }
    );
    
    // 插入缓存
    std::vector<float> keyCache(1000, 1.0f);
    std::vector<float> valueCache(1000, 2.0f);
    
    if (manager.insert("req1", keyCache, valueCache)) {
        spdlog::info("Cache inserted: req1");
    }
    
    // 获取缓存
    std::vector<float> retrievedKey;
    std::vector<float> retrievedValue;
    
    if (manager.get("req1", retrievedKey, retrievedValue)) {
        spdlog::info("Cache hit: req1");
    }
    
    // 淘汰缓存
    manager.evict("req1");
    
    // 获取内存使用情况
    size_t used = manager.getUsedMemory();
    size_t total = manager.getTotalMemory();
    
    spdlog::info("Used memory: {} MB", used / (1024 * 1024));
    spdlog::info("Total memory: {} MB", total / (1024 * 1024));
    
    return 0;
}
```

#### 11.3.3 FloatArray使用示例

```cpp
#include "raii_wrapper.h"

int main() {
    // 创建浮点数数组
    cllm::FloatArray array(1000);
    
    // 访问数组元素
    for (size_t i = 0; i < array.size(); ++i) {
        array.data()[i] = i * 1.0f;
    }
    
    // 读取数组元素
    for (size_t i = 0; i < array.size(); ++i) {
        spdlog::info("array[{}] = {}", i, array.data()[i]);
    }
    
    // 数组自动释放
    return 0;
}
```

#### 11.3.4 RAIIWrapper使用示例

```cpp
#include "raii_wrapper.h"

int main() {
    // 创建RAII包装器
    cllm::RAIIWrapper<float> wrapper(new float(42.0f));
    
    // 访问对象
    spdlog::info("Value: {}", *wrapper.get());
    
    // 释放所有权
    float* ptr = wrapper.release();
    spdlog::info("Released pointer: {}", *ptr);
    
    // 手动释放
    delete ptr;
    
    // 重置指针
    wrapper.reset(new float(24.0f));
    spdlog::info("New value: {}", *wrapper.get());
    
    // 对象自动释放
    return 0;
}
```

## 12. 依赖关系

### 12.1 模块依赖

- **MemoryMonitor**: 无依赖
- **KVCacheMemoryManager**: 依赖MemoryMonitor
- **ModelExecutorMemoryManager**: 依赖MemoryMonitor
- **FloatArray**: 无依赖
- **RAIIWrapper**: 无依赖

### 12.2 库依赖

- **mimalloc**: 内存分配器
- **spdlog**: 日志库
- **标准库**: C++标准库

### 12.3 接口依赖

- **MemoryMonitor**: 无接口依赖
- **KVCacheMemoryManager**: 无接口依赖
- **ModelExecutorMemoryManager**: 无接口依赖
- **FloatArray**: 无接口依赖
- **RAIIWrapper**: 无接口依赖

## 13. 设计检查清单

- [x] 模块职责清晰
- [x] 类设计合理
- [x] 接口设计完整
- [x] 算法设计正确
- [x] 并发设计安全
- [x] 内存管理完善
- [x] 错误处理完善
- [x] 性能优化充分
- [x] 测试设计完整
- [x] 代码示例正确
- [x] 依赖关系清晰
- [x] 符合编程规范

## 14. 总结

Memory Manager模块是cLLM系统的基础设施模块，负责系统的内存管理。本设计文档详细描述了Memory Monitor、KV Cache Memory Manager、Model Executor Memory Manager、FloatArray和RAIIWrapper的设计和实现。

主要特点：
- 使用mimalloc提供高性能内存分配
- 使用RAII包装器自动管理资源生命周期
- 实现LRU淘汰策略管理KV缓存
- 使用原子操作实现无锁并发
- 提供完善的错误处理和日志记录

本设计遵循了cLLM项目的编程规范，确保了代码的一致性和可维护性。
