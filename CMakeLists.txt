cmake_minimum_required(VERSION 3.15)
project(cllm VERSION 1.0.0 LANGUAGES C CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

# ARM64 æ¶æ„ä¼˜åŒ–ï¼ˆApple Siliconï¼‰
if(CMAKE_SYSTEM_PROCESSOR MATCHES "arm64|aarch64|ARM64")
    message(STATUS "ğŸ ARM64 architecture detected, enabling FP16/INT8 optimizations")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -march=armv8.2-a+fp16+dotprod")
    add_compile_definitions(__ARM_FP16_FORMAT_IEEE=1)
endif()

set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)

include_directories(${CMAKE_SOURCE_DIR}/include)
include_directories(${CMAKE_SOURCE_DIR}/third_party)
include_directories(${CMAKE_SOURCE_DIR}/third_party/llama.cpp/ggml/include)
include_directories(${CMAKE_SOURCE_DIR}/third_party/llama.cpp/include)

option(BUILD_TESTS "Build tests" OFF)
option(BUILD_EXAMPLES "Build examples" ON)
option(USE_LIBTORCH "Enable LibTorch backend (experimental, requires PyTorch C++ API)" OFF)

find_package(Threads REQUIRED)

# Find OpenMP for parallel processing
if(APPLE)
    if(EXISTS "/opt/homebrew/opt/libomp/lib/libomp.dylib")
        set(OpenMP_ROOT "/opt/homebrew/opt/libomp")
        message(STATUS "âœ… Using Homebrew libomp at ${OpenMP_ROOT}")
    endif()
endif()
find_package(OpenMP)
if(OpenMP_CXX_FOUND)
    message(STATUS "âœ… Found OpenMP: ${OpenMP_CXX_VERSION}")
else()
    message(STATUS "â„¹ï¸  OpenMP not found, using single-threaded kernels")
endif()

# Find nlohmann/json
find_package(nlohmann_json 3.2.0 REQUIRED)
if(nlohmann_json_FOUND)
    message(STATUS "Found nlohmann_json: ${nlohmann_json_VERSION}")
endif()

# Find Asio
find_package(asio CONFIG QUIET)
if(NOT asio_FOUND)
    message(WARNING "Asio not found. You may need to install it manually.")
    # For now, we'll skip Asio integration in this build
else()
    target_link_libraries(cllm_core PRIVATE asio::asio)
endif()

# Find YAML-CPP
find_package(yaml-cpp REQUIRED)
if(yaml-cpp_FOUND)
    message(STATUS "Found yaml-cpp: ${yaml-cpp_LIBRARIES}")
endif()

# Find spdlog
find_package(spdlog REQUIRED)

# Find LibTorch (PyTorch C++ API) - Optional
if(USE_LIBTORCH)
    set(TORCH_PATH "${CMAKE_SOURCE_DIR}/third_party/libtorch")
    list(APPEND CMAKE_PREFIX_PATH "${TORCH_PATH}")
    find_package(Torch QUIET)
    if(Torch_FOUND)
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${TORCH_CXX_FLAGS}")
        add_compile_definitions(CLLM_USE_LIBTORCH)
        message(STATUS "âœ… Found LibTorch: ${TORCH_LIBRARIES}")
        set(LIBTORCH_FOUND TRUE)
    else()
        message(WARNING "âš ï¸  LibTorch not found, LibTorchBackend will not be available")
        message(STATUS "   Download LibTorch from: https://pytorch.org/get-started/locally/")
        message(STATUS "   Extract to: ${TORCH_PATH}")
        set(LIBTORCH_FOUND FALSE)
        set(USE_LIBTORCH OFF)
    endif()
else()
    message(STATUS "â„¹ï¸  LibTorch backend disabled (USE_LIBTORCH=OFF)")
    set(LIBTORCH_FOUND FALSE)
endif()

# Find llama.cpp
set(LLAMA_CPP_BUILD_DIR "${CMAKE_SOURCE_DIR}/third_party/llama.cpp/build")
if(EXISTS "${LLAMA_CPP_BUILD_DIR}/llama-config.cmake")
    list(APPEND CMAKE_PREFIX_PATH "${LLAMA_CPP_BUILD_DIR}")
    find_package(Llama QUIET HINTS "${LLAMA_CPP_BUILD_DIR}")
    if(Llama_FOUND)
        message(STATUS "âœ… Found llama.cpp: ${llama_LIBRARY}")
        set(LLAMA_CPP_FOUND TRUE)
    else()
        message(WARNING "âš ï¸  llama.cpp not found, LlamaCppBackend will not be available")
        message(STATUS "   Build llama.cpp first: cd third_party/llama.cpp && mkdir -p build && cd build && cmake .. && make -j$(sysctl -n hw.ncpu)")
        set(LLAMA_CPP_FOUND FALSE)
    endif()
else()
    message(WARNING "âš ï¸  llama.cpp build directory not found, LlamaCppBackend will not be available")
    message(STATUS "   Build llama.cpp first: cd third_party/llama.cpp && mkdir -p build && cd build && cmake .. && make -j$(sysctl -n hw.ncpu)")
    set(LLAMA_CPP_FOUND FALSE)
endif()

# Tokenizers é€‰é¡¹ (âœ… é»˜è®¤å¯ç”¨)
option(USE_TOKENIZERS_CPP "Use tokenizers-cpp for HuggingFace tokenizer" ON)

if(USE_TOKENIZERS_CPP)
    message(STATUS "âœ… Enabling HuggingFace tokenizers support (tokenizers-cpp)")
    
    # æŸ¥æ‰¾tokenizers-cppå¤´æ–‡ä»¶
    find_path(TOKENIZERS_INCLUDE_DIR 
        NAMES tokenizers_cpp.h tokenizers_c.h
        PATHS 
            /opt/homebrew/include
            /usr/local/include
            ${CMAKE_SOURCE_DIR}/third_party/tokenizers-cpp/include
    )
    
    # æŸ¥æ‰¾tokenizers-cppåº“æ–‡ä»¶
    find_library(TOKENIZERS_LIBRARY 
        NAMES tokenizers_cpp
        PATHS 
            /opt/homebrew/lib
            /usr/local/lib
            ${CMAKE_SOURCE_DIR}/third_party/tokenizers-cpp/lib
            ${CMAKE_SOURCE_DIR}/third_party/tokenizers-cpp/build
    )
    
    # æŸ¥æ‰¾tokenizers_cåº“ (Rustéƒ¨åˆ†)
    find_library(TOKENIZERS_C_LIBRARY 
        NAMES tokenizers_c
        PATHS 
            /opt/homebrew/lib
            /usr/local/lib
            ${CMAKE_SOURCE_DIR}/third_party/tokenizers-cpp/lib
            ${CMAKE_SOURCE_DIR}/third_party/tokenizers-cpp/build
    )

    # æŸ¥æ‰¾sentencepieceåº“ (tokenizers-cppä¾èµ–)
    find_library(TOKENIZERS_SP_LIBRARY 
        NAMES sentencepiece
        PATHS 
            ${CMAKE_SOURCE_DIR}/third_party/tokenizers-cpp/build/sentencepiece/src
    )
    
    if(TOKENIZERS_INCLUDE_DIR AND TOKENIZERS_LIBRARY AND TOKENIZERS_C_LIBRARY)
        message(STATUS "âœ… Found tokenizers-cpp:")
        message(STATUS "   Include: ${TOKENIZERS_INCLUDE_DIR}")
        message(STATUS "   Library (CPP): ${TOKENIZERS_LIBRARY}")
        message(STATUS "   Library (C): ${TOKENIZERS_C_LIBRARY}")
        
        add_compile_definitions(USE_TOKENIZERS_CPP)
        include_directories(${TOKENIZERS_INCLUDE_DIR})
        
        set(TOKENIZERS_LIBRARIES ${TOKENIZERS_LIBRARY} ${TOKENIZERS_C_LIBRARY})
        if(TOKENIZERS_SP_LIBRARY)
            list(APPEND TOKENIZERS_LIBRARIES ${TOKENIZERS_SP_LIBRARY})
        endif()
    else()
        message(WARNING "âš ï¸  tokenizers-cpp not found, falling back to NativeTokenizer")
        message(WARNING "   Install guide: https://github.com/mlc-ai/tokenizers-cpp")
        message(STATUS "   Quick install on macOS:")
        message(STATUS "     brew install rust")
        message(STATUS "     git clone https://github.com/mlc-ai/tokenizers-cpp")
        message(STATUS "     cd tokenizers-cpp && mkdir build && cd build")
        message(STATUS "     cmake .. -DCMAKE_INSTALL_PREFIX=/opt/homebrew")
        message(STATUS "     make -j8 && make install")
        set(USE_TOKENIZERS_CPP OFF)
    endif()
else()
    message(STATUS "âŒ HuggingFace tokenizers support disabled")
endif()

# Find SentencePiece - try multiple methods
find_package(PkgConfig QUIET)
if(PkgConfig_FOUND)
    pkg_check_modules(SentencePiece QUIET sentencepiece)
    if(SentencePiece_FOUND)
        message(STATUS "Found SentencePiece via pkg-config: ${SentencePiece_LIBRARIES}")
        include_directories(${SentencePiece_INCLUDE_DIRS})
    endif()
endif()

# If pkg-config failed, try manual find
if(NOT SentencePiece_FOUND)
    find_path(SentencePiece_INCLUDE_DIRS
        NAMES sentencepiece_processor.h
        PATHS /usr/include /usr/local/include /opt/homebrew/include
        PATH_SUFFIXES sentencepiece
    )
    
    find_library(SentencePiece_LIBRARIES
        NAMES sentencepiece
        PATHS /usr/lib /usr/local/lib /opt/homebrew/lib
    )
    
    if(SentencePiece_INCLUDE_DIRS AND SentencePiece_LIBRARIES)
        message(STATUS "Found SentencePiece manually: ${SentencePiece_LIBRARIES}")
        include_directories(${SentencePiece_INCLUDE_DIRS})
        set(SentencePiece_FOUND TRUE)
    else()
        message(FATAL_ERROR "SentencePiece not found. Please install it and set SentencePiece_ROOT")
    endif()
endif()

# bs_thread_pool åœ¨ third_party/CMakeLists.txt ä¸­å®šä¹‰ï¼Œä½†æˆ‘ä»¬åœ¨ç”Ÿäº§ç¯å¢ƒè·³è¿‡
# CTokenizer sources are now available via CTOKENIZER_SOURCES variable

add_library(cllm_core
    src/common/config.cpp
    src/common/types.cpp
    src/common/utils.cpp
    src/common/json.cpp
    src/common/logger.cpp
    src/common/asio_handler.cpp
    src/common/memory_utils.cpp
    src/common/time_utils.cpp
    src/memory/monitor.cpp
    src/memory/float_array.cpp
    src/memory/cache_manager.cpp
    src/memory/executor_manager.cpp
    src/thread_pool/manager.cpp
    src/thread_pool/monitor.cpp
    src/common/queue.cpp
    src/common/request_state.cpp
    src/batch/manager.cpp
    src/batch/processor.cpp
    src/kv_cache/cache.cpp
    src/kv_cache/cache_manager.cpp
    src/sampler/sampler.cpp
    src/sampler/config.cpp
    src/sampler/stats.cpp
    src/model/config.cpp
    src/model/executor.cpp
    src/model/stats.cpp
    src/model/inference_optimizer.cpp
    src/model/quantization_manager.cpp
    src/model/batch_processor.cpp
    src/model/loader_interface.cpp
    src/model/weight_data.cpp
    src/model/gguf_loader_new.cpp
    src/model/gguf_dequantization.cpp
    src/kylin/core/kernels.cpp
    src/kylin/core/ggml_kernels.cpp
    src/kylin/core/quantization.cpp
    src/kylin/core/tensor_stats.cpp
    src/kylin/ops/rope.cpp
    src/kylin/ops/attention.cpp
    src/kylin/ops/attention_graph.cpp
    src/kylin/ops/feed_forward.cpp
    src/kylin/ops/kv_cache_ops.cpp
    src/kylin/model/transformer_block.cpp
    src/kylin/model/transformer_model.cpp
    src/kylin/model/model_loader.cpp
    src/kylin/hf/transformer.cpp
    src/kylin/hf/config.cpp
    src/kylin/hf/safetensors_loader.cpp
    src/kylin/hf/kv_cache_pool.cpp
    src/kylin/backend/cpu/cpu_backend.cpp
    src/kylin/backend/cpu/ggml_cpu_impl.cpp
    src/kylin/backend/gpu/gpu_backend.cpp
    src/kylin/backend/gpu/ggml_backend_impl.cpp
    src/kylin/gguf/loader.cpp
    src/kylin/gguf/transformer.cpp
    src/kylin/gguf/ggml_operator.cpp
    src/kylin/gguf/context.cpp
    src/kylin/gguf/operator_interface.cpp
    src/kylin/gguf/native_operator.cpp
    src/inference/inference_engine.cpp
    src/inference/backend_factory.cpp
    src/inference/kylin_backend.cpp
    src/inference/llama_cpp_backend.cpp
    src/inference/kv_cache_manager.cpp
    src/scheduler/scheduler.cpp
    src/scheduler/stats.cpp
    src/scheduler/tracker.cpp
    src/scheduler/batch_processor.cpp
    src/scheduler/dynamic_batch_tuner.cpp
    src/tokenizer/token.cpp
    src/tokenizer/config.cpp
    src/tokenizer/request.cpp
    src/tokenizer/response.cpp
    src/tokenizer/stats.cpp
    src/tokenizer/tokenizer.cpp
    src/tokenizer/generator.cpp
    src/tokenizer/manager.cpp
    src/tokenizer/json_tokenizer.cpp
    src/tokenizer/qwen2_tokenizer.cpp
    src/tokenizer/hf_tokenizer.cpp
    src/tokenizer/native_tokenizer.cpp
    src/tokenizer/unicode_utils.cpp
    src/tokenizer/unified_tokenizer.cpp
    src/tokenizer/gguf_tokenizer.cpp
    src/http/request.cpp
    src/http/response.cpp
    src/http/request_validator.cpp
    src/http/response_builder.cpp
    src/http/handler.cpp
    src/http/api_endpoint.cpp
    src/http/health_endpoint.cpp
    src/http/generate_endpoint.cpp
    src/http/encode_endpoint.cpp
    src/http/benchmark_endpoint.cpp
    src/http/model_info_endpoint.cpp
    src/http/http_server.cpp
    src/http/json_request_parser.cpp
    src/http/request_queue.cpp
    ${CTOKENIZER_SOURCES}
)

target_link_libraries(cllm_core PUBLIC
    Threads::Threads
    spdlog::spdlog
)
target_link_libraries(cllm_core PRIVATE
    yaml-cpp::yaml-cpp
    ${SentencePiece_LIBRARIES}
    ${TOKENIZERS_LIBRARIES}  # âœ… Add tokenizers-cpp
)

# Conditionally add LibTorch backend
if(LIBTORCH_FOUND)
    target_sources(cllm_core PRIVATE src/inference/libtorch_backend.cpp)
    target_link_libraries(cllm_core PRIVATE "${TORCH_LIBRARIES}")
    target_compile_definitions(cllm_core PRIVATE CLLM_USE_LIBTORCH)
    message(STATUS "âœ… Linked LibTorch library")
endif()

# Apple Accelerate framework for BLAS
if(APPLE)
    find_library(ACCELERATE_FRAMEWORK Accelerate)
    if(ACCELERATE_FRAMEWORK)
        target_link_libraries(cllm_core PRIVATE ${ACCELERATE_FRAMEWORK})
        message(STATUS "âœ… Linked Apple Accelerate framework for BLAS")
    endif()
endif()

# OpenMP for parallel processing
if(OpenMP_CXX_FOUND)
    target_link_libraries(cllm_core PRIVATE OpenMP::OpenMP_CXX)
    message(STATUS "âœ… Linked OpenMP for parallel kernels")
endif()

# Link llama.cpp if available
if(LLAMA_CPP_FOUND)
    target_sources(cllm_core PRIVATE src/inference/llama_cpp_backend.cpp)
    # æ·»åŠ  llama.cpp include ç›®å½•
    include_directories(${CMAKE_SOURCE_DIR}/third_party/llama.cpp/include)
    include_directories(${CMAKE_SOURCE_DIR}/third_party/llama.cpp/install/include)
    target_link_libraries(cllm_core PRIVATE llama)
    target_compile_definitions(cllm_core PRIVATE CLLM_USE_LLAMA_CPP)
    message(STATUS "âœ… Linked llama.cpp library")
    
    # Link GGML Metal for GPU support on macOS
    if(APPLE)
        # æ–°ç‰ˆæœ¬çš„ llama.cpp æŠŠåº“æ–‡ä»¶æ”¾åœ¨ bin ç›®å½•ä¸‹
        set(GGML_METAL_LIB "${CMAKE_SOURCE_DIR}/third_party/llama.cpp/build/bin/libggml-metal.dylib")
        if(NOT EXISTS "${GGML_METAL_LIB}")
            # å°è¯•æ—§ç‰ˆæœ¬çš„ lib ç›®å½•
            set(GGML_METAL_LIB "${CMAKE_SOURCE_DIR}/third_party/llama.cpp/build/lib/libggml-metal.dylib")
        endif()
        if(EXISTS "${GGML_METAL_LIB}")
            target_link_libraries(cllm_core PRIVATE "${GGML_METAL_LIB}")
            target_compile_definitions(cllm_core PRIVATE GGML_USE_METAL)
            # Link Metal and Foundation frameworks
            find_library(METAL_FRAMEWORK Metal)
            find_library(FOUNDATION_FRAMEWORK Foundation)
            find_library(METALKIT_FRAMEWORK MetalKit)
            if(METAL_FRAMEWORK AND FOUNDATION_FRAMEWORK)
                target_link_libraries(cllm_core PRIVATE 
                    ${METAL_FRAMEWORK} 
                    ${FOUNDATION_FRAMEWORK}
                    ${METALKIT_FRAMEWORK})
                message(STATUS "âœ… Linked GGML Metal library for GPU acceleration")
            endif()
        else()
            message(STATUS "â„¹ï¸  GGML Metal library not found, GPU acceleration disabled")
        endif()
    endif()
else()
    message(STATUS "â„¹ï¸  llama.cpp not available, LlamaCppBackend disabled")
endif()

# Set ASIO_STANDALONE flag to use header-only version
if(NOT asio_FOUND)
    target_compile_definitions(cllm_core PUBLIC ASIO_STANDALONE)
endif()

if(BUILD_TESTS)
    add_subdirectory(third_party/googletest)
    enable_testing()
    add_subdirectory(tests)
    
    # HFTokenizer ä¸“é¡¹æµ‹è¯• - æš‚æ—¶æ³¨é‡Šæ‰ï¼Œæ–‡ä»¶ä¸å­˜åœ¨
    # add_executable(test_hf_tokenizer
    #     tests/test_hf_tokenizer.cpp
    # )
    # target_link_libraries(test_hf_tokenizer
    #     cllm_core
    #     gtest
    #     gtest_main
    #     Threads::Threads
    # )
    # add_test(NAME HFTokenizerTest COMMAND test_hf_tokenizer)
    
    # GGUF Loader å®Œæ•´æµ‹è¯• - æš‚æ—¶æ³¨é‡Šæ‰ï¼Œå› ä¸ºéœ€è¦æ›´æ–°æµ‹è¯•ä»¥é€‚é…æ–°çš„GGUFLoaderæ¥å£
    # add_executable(test_gguf_loader_complete
    #     tests/test_gguf_loader_complete.cpp
    # )
    # target_link_libraries(test_gguf_loader_complete
    #     cllm_core
    #     gtest
    #     gtest_main
    #     Threads::Threads
    # )
    # add_test(NAME GGUFLoaderCompleteTest COMMAND test_gguf_loader_complete)
    
    # GGUF Loader æ‰‹åŠ¨æµ‹è¯•ç¨‹åº - æš‚æ—¶æ³¨é‡Šæ‰ï¼Œæ–‡ä»¶ä¸å­˜åœ¨
    # add_executable(test_gguf_full
    #     tests/test_gguf_loading.cpp
    # )
    # target_link_libraries(test_gguf_full
    #     cllm_core
    #     Threads::Threads
    # )
    
    # Kylinå¼•æ“GGUF Q4_K_Mæ¨ç†æµ‹è¯•
    add_executable(test_kylin_gguf_q4k
        tests/kylin_test_suite/test_kylin_gguf_q4k.cpp
    )
    target_link_libraries(test_kylin_gguf_q4k
        cllm_core
        gtest
        gtest_main
        Threads::Threads
        spdlog::spdlog
    )
    add_test(NAME KylinGGUFQ4KTest COMMAND test_kylin_gguf_q4k)
    
    # Kylin å¼•æ“ç²¾ç»†åŒ–æ€§èƒ½åŸºå‡†æµ‹è¯• - æµ‹è¯•å¤±è´¥ï¼Œæš‚æ—¶æ³¨é‡Š
    # add_executable(test_kylin_detailed_benchmark
    #     tests/test_kylin_detailed_benchmark.cpp
    # )
    # target_link_libraries(test_kylin_detailed_benchmark
    #     cllm_core
    #     gtest
    #     gtest_main
    #     Threads::Threads
    #     spdlog::spdlog
    # )
    # add_test(NAME KylinDetailedBenchmarkTest COMMAND test_kylin_detailed_benchmark)
    
    # ç®€å•çš„ hello æ¨ç†æµ‹è¯• - æš‚æ—¶æ³¨é‡Šæ‰ï¼Œæ–‡ä»¶ä¸å­˜åœ¨
    # add_executable(test_hello_inference
    #     tests/test_hello_inference.cpp
    # )
    # target_link_libraries(test_hello_inference
    #     cllm_core
    #     Threads::Threads
    # )
    
    # llama.cpp åç«¯ GGUF æµ‹è¯•
    add_executable(test_llama_cpp_backend_gguf
        tests/llama_cpp_test_suite/test_llama_cpp_backend_gguf.cpp
    )
    target_link_libraries(test_llama_cpp_backend_gguf
        cllm_core
        Threads::Threads
        spdlog::spdlog
    )
    
    # æ¡ä»¶é“¾æ¥ llama.cppï¼ˆå¦‚æœå¯ç”¨ï¼‰
    if(LLAMA_CPP_FOUND)
        target_compile_definitions(test_llama_cpp_backend_gguf PRIVATE CLLM_USE_LLAMA_CPP)
    else()
        message(WARNING "âš ï¸  test_llama_cpp_backend_gguf requires llama.cpp, but it's not available")
    endif()
    
    # Phase 2: åºåˆ—IDç®¡ç†å•å…ƒæµ‹è¯•
    add_executable(test_sequence_id_manager
        tests/llama_cpp_test_suite/test_sequence_id_manager.cpp
    )
    target_link_libraries(test_sequence_id_manager
        cllm_core
        gtest
        gtest_main
        Threads::Threads
        spdlog::spdlog
    )
    if(LLAMA_CPP_FOUND)
        target_compile_definitions(test_sequence_id_manager PRIVATE CLLM_USE_LLAMA_CPP)
        add_test(NAME SequenceIdManagerTest COMMAND test_sequence_id_manager)
    else()
        message(WARNING "âš ï¸  test_sequence_id_manager requires llama.cpp, but it's not available")
    endif()
    
    # Phase 2: åºåˆ—IDç®¡ç†å•å…ƒæµ‹è¯•ï¼ˆç®€åŒ–ç‰ˆï¼Œä¸ä¾èµ–åç«¯åˆå§‹åŒ–ï¼‰
    add_executable(test_sequence_id_manager_simple
        tests/llama_cpp_test_suite/test_sequence_id_manager_simple.cpp
    )
    target_link_libraries(test_sequence_id_manager_simple
        gtest
        gtest_main
        Threads::Threads
        spdlog::spdlog
    )
    add_test(NAME SequenceIdManagerSimpleTest COMMAND test_sequence_id_manager_simple)
    
    # Phase 1: çŠ¶æ€è½¬æ¢ä¸“é¡¹æµ‹è¯• - æµ‹è¯•å¤±è´¥ï¼Œæš‚æ—¶æ³¨é‡Š
    # add_executable(test_state_transition
    #     tests/test_state_transition.cpp
    # )
    # target_link_libraries(test_state_transition
    #     cllm_core
    #     gtest
    #     gtest_main
    #     Threads::Threads
    #     spdlog::spdlog
    # )
    # add_test(NAME StateTransitionTest COMMAND test_state_transition)
    
    # Phase 1: çŠ¶æ€è½¬æ¢ä¸“é¡¹æµ‹è¯•ï¼ˆç®€åŒ–ç‰ˆï¼Œä¸ä¾èµ– Scheduler åˆå§‹åŒ–ï¼‰
    add_executable(test_state_transition_simple
        tests/test_state_transition_simple.cpp
    )
    target_link_libraries(test_state_transition_simple
        cllm_core
        gtest
        gtest_main
        Threads::Threads
        spdlog::spdlog
    )
    add_test(NAME StateTransitionSimpleTest COMMAND test_state_transition_simple)
    
    # Phase 3: è¶…æ—¶æ£€æµ‹æœºåˆ¶
    add_executable(test_timeout_detection
        tests/test_timeout_detection.cpp
    )
    target_link_libraries(test_timeout_detection
        gtest
        gtest_main
        Threads::Threads
        spdlog::spdlog
    )
    add_test(NAME TimeoutDetectionTest COMMAND test_timeout_detection)
    
    # Phase 4: KVç¼“å­˜ç»Ÿè®¡ç®¡ç† - æµ‹è¯•å¤±è´¥ï¼Œæš‚æ—¶æ³¨é‡Š
    # add_executable(test_kv_cache_manager
    #     tests/test_kv_cache_manager.cpp
    # )
    # target_link_libraries(test_kv_cache_manager
    #     cllm_core
    #     gtest
    #     gtest_main
    #     Threads::Threads
    #     spdlog::spdlog
    # )
    # add_test(NAME KVCacheManagerTest COMMAND test_kv_cache_manager)
    
    # Phase 5: KVç¼“å­˜LRUæ·˜æ±°
    add_executable(test_kv_cache_lru_eviction
        tests/test_kv_cache_lru_eviction.cpp
    )
    target_link_libraries(test_kv_cache_lru_eviction
        cllm_core
        gtest
        gtest_main
        Threads::Threads
        spdlog::spdlog
    )
    add_test(NAME KVCacheLRUEvictionTest COMMAND test_kv_cache_lru_eviction)
    
    # Phase 6: HTTPå±‚å¹¶å‘æ£€æŸ¥ - æµ‹è¯•å¤±è´¥ï¼Œæš‚æ—¶æ³¨é‡Š
    # add_executable(test_http_concurrency
    #     tests/test_http_concurrency.cpp
    # )
    # target_link_libraries(test_http_concurrency
    #     cllm_core
    #     gtest
    #     gtest_main
    #     Threads::Threads
    #     spdlog::spdlog
    #     nlohmann_json::nlohmann_json
    # )
    # add_test(NAME HttpConcurrencyTest COMMAND test_http_concurrency)
    
    # Phase 7: å“åº”å›è°ƒæœºåˆ¶ - æµ‹è¯•å¤±è´¥ï¼Œæš‚æ—¶æ³¨é‡Š
    # add_executable(test_response_callback
    #     tests/test_response_callback.cpp
    # )
    # target_link_libraries(test_response_callback
    #     cllm_core
    #     gtest
    #     gtest_main
    #     Threads::Threads
    #     spdlog::spdlog
    # )
    # add_test(NAME ResponseCallbackTest COMMAND test_response_callback)
    
    # Phase 7: å“åº”å›è°ƒæœºåˆ¶ï¼ˆç®€åŒ–æµ‹è¯•ï¼‰
    add_executable(test_response_callback_simple
        tests/test_response_callback_simple.cpp
    )
    target_link_libraries(test_response_callback_simple
        cllm_core
        gtest
        gtest_main
        Threads::Threads
        spdlog::spdlog
    )
    add_test(NAME ResponseCallbackSimpleTest COMMAND test_response_callback_simple)
    
    # Phase 7: é›†æˆæµ‹è¯• - /generateæ¥å£ï¼ˆç®€åŒ–ç‰ˆï¼‰- æµ‹è¯•å¤±è´¥ï¼Œæš‚æ—¶æ³¨é‡Š
    # add_executable(test_generate_simple
    #     tests/test_generate_simple.cpp
    # )
    # target_link_libraries(test_generate_simple
    #     cllm_core
    #     gtest
    #     gtest_main
    #     Threads::Threads
    #     spdlog::spdlog
    #     nlohmann_json::nlohmann_json
    # )
    # add_test(NAME GenerateSimpleTest COMMAND test_generate_simple)
    
    # åŠ è½½Qwenæ¨¡å‹çš„æµ‹è¯•ç¨‹åº
    add_executable(load_qwen_model
        examples/load_qwen_model.cpp
    )
    target_link_libraries(load_qwen_model
        cllm_core
        Threads::Threads
        spdlog::spdlog
    )
endif()

if(BUILD_EXAMPLES)
    add_subdirectory(examples)
    
    # HFTokenizer ç¤ºä¾‹
    add_executable(hf_tokenizer_example
        examples/hf_tokenizer_example.cpp
    )
    target_link_libraries(hf_tokenizer_example
        cllm_core
        Threads::Threads
    )
endif()

# Add executable for the main program
add_executable(cllm_server src/main.cpp)

# Add test server executable
target_link_libraries(cllm_server
    cllm_core
    Threads::Threads
)

# æ·»åŠ ç›´æ¥æ€§èƒ½æµ‹è¯•ç¨‹åºï¼ˆå‚è€ƒ llama-benchï¼‰
add_executable(direct_benchmark ${CMAKE_SOURCE_DIR}/tools/direct_benchmark.cpp)
target_link_libraries(direct_benchmark
    cllm_core
    Threads::Threads
    spdlog::spdlog
)
if(LLAMA_CPP_FOUND)
    target_compile_definitions(direct_benchmark PRIVATE CLLM_USE_LLAMA_CPP)
endif()

add_executable(show_model_output ${CMAKE_SOURCE_DIR}/tools/show_model_output.cpp)
target_link_libraries(show_model_output
    cllm_core
    Threads::Threads
    spdlog::spdlog
)

# GPU æ‰¹å¤„ç†æµ‹è¯•ç¨‹åº
add_executable(test_gpu_batch ${CMAKE_SOURCE_DIR}/src/test_gpu_batch.cpp)
target_link_libraries(test_gpu_batch
    cllm_core
    Threads::Threads
    spdlog::spdlog
)

# å¹¶å‘æ¨ç†æµ‹è¯•ç¨‹åº
add_executable(test_concurrent_inference ${CMAKE_SOURCE_DIR}/src/test_concurrent_inference.cpp)
target_link_libraries(test_concurrent_inference
    cllm_core
    Threads::Threads
    spdlog::spdlog
)
if(LLAMA_CPP_FOUND)
    target_compile_definitions(show_model_output PRIVATE CLLM_USE_LLAMA_CPP)
endif()

# æ·»åŠ æ¸è¿›å¼æ€§èƒ½æµ‹è¯•ç¨‹åºï¼ˆé€æ­¥éªŒè¯å„é˜¶æ®µæ€§èƒ½è¡°å‡ï¼‰
# add_executable(incremental_benchmark ${CMAKE_SOURCE_DIR}/tools/incremental_benchmark.cpp)
# target_link_libraries(incremental_benchmark
#     cllm_core
#     Threads::Threads
#     spdlog::spdlog
# )
# if(LLAMA_CPP_FOUND)
#     target_compile_definitions(incremental_benchmark PRIVATE CLLM_USE_LLAMA_CPP)
# endif()

# æ·»åŠ  Kylin åˆ†é˜¶æ®µæµ‹è¯•ç¨‹åº
# add_executable(kylin_stage_test ${CMAKE_SOURCE_DIR}/tools/kylin_stage_test.cpp)
# target_link_libraries(kylin_stage_test
#     cllm_core
#     Threads::Threads
#     spdlog::spdlog
# )
# if(LLAMA_CPP_FOUND)
#     target_compile_definitions(kylin_stage_test PRIVATE CLLM_USE_LLAMA_CPP)
# endif()

# =============================================================================
# CPack é…ç½® - è·¨å¹³å°æ‰“åŒ…
# =============================================================================
include(InstallRequiredSystemLibraries)
set(CPACK_PACKAGE_NAME "cLLM")
set(CPACK_PACKAGE_VENDOR "cLLM Team")
set(CPACK_PACKAGE_VERSION_MAJOR ${PROJECT_VERSION_MAJOR})
set(CPACK_PACKAGE_VERSION_MINOR ${PROJECT_VERSION_MINOR})
set(CPACK_PACKAGE_VERSION_PATCH ${PROJECT_VERSION_PATCH})
set(CPACK_PACKAGE_DESCRIPTION_SUMMARY "cLLM - High-performance LLM Inference Framework")

# Tar åŒ…æ’é™¤æ–‡ä»¶
set(CPACK_TAR_EXCLUDE_FROM_SOURCE_LIST "/build/;/\\\\.git/;*.o;*.a;*.dylib;*.so;*.log;*.md;*.DS_Store")
set(CPACK_SOURCE_TAR_EXCLUDE_FROM_SOURCE_LIST "/build/;/\\\\.git/;*.o;*.a;*.dylib;*.so;*.log;*.md;*.DS_Store")

# æºæ–‡ä»¶æ‰“åŒ…ç”Ÿæˆå™¨
set(CPACK_SOURCE_GENERATOR "TGZ")

# äºŒè¿›åˆ¶æ‰“åŒ…ç”Ÿæˆå™¨ï¼ˆæ ¹æ®å¹³å°è‡ªåŠ¨é€‰æ‹©ï¼‰
if(WIN32)
    set(CPACK_GENERATOR "ZIP")
elseif(APPLE)
    set(CPACK_GENERATOR "TGZ")
else()
    set(CPACK_GENERATOR "TGZ")
endif()

# å®‰è£…è§„åˆ™
install(TARGETS cllm_core cllm_server direct_benchmark
        RUNTIME DESTINATION bin
        LIBRARY DESTINATION lib
        ARCHIVE DESTINATION lib)

install(DIRECTORY ${CMAKE_SOURCE_DIR}/config/
        DESTINATION etc/cLLM
        FILES_MATCHING PATTERN "*.yaml")

install(FILES ${CMAKE_SOURCE_DIR}/README.md
        DESTINATION .)

# è‡ªå®šä¹‰æ‰“åŒ…ç›®æ ‡ï¼ˆè§£å†³ macOS æ‰©å±•å±æ€§é—®é¢˜ï¼‰
add_custom_target(package-linux
    COMMAND ${CMAKE_COMMAND} -E env COPYFILE_DISABLE=1
    ${CMAKE_COMMAND} -E make_directory ${CMAKE_BINARY_DIR}/package
    COMMAND make install DESTDIR=${CMAKE_BINARY_DIR}/package
    COMMAND ${CMAKE_COMMAND} -E chdir ${CMAKE_BINARY_DIR}/package/usr/local
        gtar --no-xattrs -czvf ${CMAKE_BINARY_DIR}/cLLM-${PROJECT_VERSION}-Darwin-linux-compatible.tar.gz .
    COMMAND ${CMAKE_COMMAND} -E echo "Package created: ${CMAKE_BINARY_DIR}/cLLM-${PROJECT_VERSION}-Darwin-linux-compatible.tar.gz"
    WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
    COMMENT "Creating Linux-compatible package without extended attributes"
)

include(CPack)

# ä½¿ç”¨è¯´æ˜ï¼š
# macOS æ‰“åŒ…åˆ° Linux å…¼å®¹ï¼š
#   make package-linux
# 
# æˆ–è€…æ‰‹åŠ¨ï¼š
#   make install DESTDIR=/tmp/cLLM-install
#   cd /tmp/cLLM-install/usr/local && gtar --no-xattrs -czf cLLM-1.0.0-Darwin-linux-compatible.tar.gz .
# =============================================================================


